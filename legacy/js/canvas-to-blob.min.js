!(function (t) { 'use strict'; const e = t.HTMLCanvasElement && t.HTMLCanvasElement.prototype; const o = t.Blob && (function () { try { return Boolean(new Blob()); } catch (t) { return !1; } }()); const n = o && t.Uint8Array && (function () { try { return new Blob([new Uint8Array(100)]).size === 100; } catch (t) { return !1; } }()); const r = t.BlobBuilder || t.WebKitBlobBuilder || t.MozBlobBuilder || t.MSBlobBuilder; const a = /^data:((.*?)(;charset=.*?)?)(;base64)?,/; const i = (o || r) && t.atob && t.ArrayBuffer && t.Uint8Array && function (t) { let e, i, l, u, b, c, d, B, f; if (!(e = t.match(a))) { throw new Error('invalid data URI'); } for (i = e[2] ? e[1] : 'text/plain' + (e[3] || ';charset=US-ASCII'), l = !!e[4], u = t.slice(e[0].length), b = l ? atob(u) : decodeURIComponent(u), c = new ArrayBuffer(b.length), d = new Uint8Array(c), B = 0; B < b.length; B += 1) { d[B] = b.charCodeAt(B); } return o ? new Blob([n ? d : c], { type: i }) : ((f = new r()).append(c), f.getBlob(i)); }; t.HTMLCanvasElement && !e.toBlob && (e.mozGetAsFile ? e.toBlob = function (t, o, n) { t(n && e.toDataURL && i ? i(this.toDataURL(o, n)) : this.mozGetAsFile('blob', o)); } : e.toDataURL && i && (e.toBlob = function (t, e, o) { t(i(this.toDataURL(e, o))); })), typeof define === 'function' && define.amd ? define(function () { return i; }) : typeof module === 'object' && module.exports ? module.exports = i : t.dataURLtoBlob = i; }(window));
